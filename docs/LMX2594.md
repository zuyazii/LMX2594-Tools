---
tags:
  - LMX2594
public: "false"
---
# Specifications
---
- **50MHz** Reference clock crystal oscillator
- **+5V** Independent power supply
- Output power decreases with frequency
- Two LED lights on the broad:
	1. Power LED (red)
	2. Lock indicator LED (blue)
	The lock indicator LED must be on to ensure there is an successful configuration and frequency output.

The official user guide and technical documents from the Texas Instrument can be found at [[LMX2594 User's Guide.pdf]] and [[LMX2594 Technical Document.pdf]]. 

Since it is not Ti's official LMX2594 development board, the schematics and specifications could be slightly different than the original ones. [[LMX2594 Module User's Guider (from vendor).pdf]] and [[LMX2594 Schematic.pdf]] could be useful in such cases. 

# PLL
---

A Phase-Locked Loop (PLL) is a frequency and phase synchronization technique utilizing **feedback control principles**. Its primary function is to maintain **synchronization between the circuit's output clock signal and an external reference clock**.

When the frequency or phase of the reference signal changes, the PLL detects this deviation. Through its internal feedback system, it adjusts the output frequency until both signals resynchronize. This state of synchronization is known as "Phase-locked."

Specifically, when the input frequency at the **+IN** terminal is higher than that at the **-IN** terminal, the charge pump output sources (pushes) current. After being integrated by the PLL low-pass filter, this causes the VCO tuning voltage to rise. Consequently, the **-IN** frequency increases alongside the VCO frequency, and the two inputs eventually converge or lockPtba to the same frequency.

## How it Works in LMX2594

1. **Receiving Reference Clock**: You provide it with a standard 50MHz clock signal (acting like a metronome).
2. **Comparison & Adjustment**: It features an internal VCO (Voltage Controlled Oscillator) capable of generating high-frequency signals between 7.5 and 15 GHz.
3. **Feedback & Locking**: It continuously divides down the internal high-frequency signal to compare it against the reference clock until they are perfectly aligned (a state known as "Lock").

# Register
---

LMX2594 uses a 24-bit SPI message for configuration:

``` text
[RW bit] [Address (7 bits)] [Data 16 bits] 
   0/1         R0-R127           Value
```

The following address and the corresponding values are useful to this project's use:

| Address | Value      | What is it             |
| ------- | ---------- | ---------------------- |
| 0       | 0x00002518 | Enable VCO calibration |
| 36      | 0x00236B80 | N Divider = 144        |
| 75      | 0x004917C0 | CHDIV = 4              |

To generate a frequency `fOUT`, the equation below can be used:

$$
f_\text{OUT}=\frac{f_\text{VCO}}{(\text{CHDIV} \times 2)}
$$

- $f_\text{VCO}$: Frequency that the VCO generated (7.5-15 GHz), equals to $f_{\text{PD}} \times N$
	- $N$: Feedback divider
	- $f_{\text{PD}}$: Frequency of the phase meter (50 MHz for this board)
- $CHDIV$: Channel divider, optional

It is needed to set `FCALEN = 1` to trigger VCO recalibration per frequency change.

In case that it is needed to change the frequency of the generated signal, the recommended flow is:

``` python
# 1. Calculate and update the value of N divider
write_register(R34_R36, new_N_value)

# 2. Update the fraction
write_register(R42_R43, new_NUM_value)
write_register(R38_R39, DEN_value)  # Usually fixed

# 3. Trigger VCO calibration
write_register(R0, FCALEN=1)

# 4. Wait for Lock Detect
# Check MUXout or read rbLDVTUNE condition
```

# Architecture
---
``` mermaid
graph TD
    %% Subgraph for the PC side
    subgraph Computer_Control [Computer/Control System]
        PC_Config[PC Software<br>Configuration]
    end

    %% Subgraph for the Interface
    subgraph USB2ANY_Interface [USB2ANY Interface]
        USB_Int[USB Interface]
        SPI_Ctrl[SPI Controller]
        USB_Int -->|Serial Data| SPI_Ctrl
    end

    %% Main Subgraph for the PLL Chip
    subgraph LMX2594 [LMX2594 PLL Synthesizer]
        Ref_In[Reference Input<br>50 MHz]
        SPI_Reg[SPI Registers]

        %% Nested Subgraph for PLL Core
        subgraph PLL_Core [PLL Core]
            PFD[Phase Freq<br>Detector]
            CP[Charge Pump]
            LF[Loop Filter]
            PFD --> CP
            CP --> LF
        end

        %% Nested Subgraph for Frequency Generation
        subgraph Freq_Gen [Frequency Generation]
            VCO[VCO<br>14.4 GHz<br>N x 50MHz]
            N_Div[N-Divider<br>N = 288]
            Ch_Div[Channel Divider<br>/ 4]
        end

        Output_Mux[Output Mux]

        %% Connections within LMX2594
        Ref_In -->|50 MHz| PFD
        LF -->|Control Volt| VCO
        VCO -->|Feedback| N_Div
        N_Div -->|Feedback| PFD
        VCO --> Ch_Div
        Ch_Div -->|3.6 GHz| Output_Mux

        %% Configuration Arrows (Dotted)
        SPI_Reg -.->|Configure| PLL_Core
        SPI_Reg -.->|Configure| Freq_Gen
    end

    %% Subgraph for Output
    subgraph Output_Stage [Output Stage]
        RF_Out[RF Output<br>3.6 GHz]
    end

    Analyzer[tinySA Ultra<br>Analyzer]

    %% External Connections
    PC_Config -->|USB Protocol| USB_Int
    SPI_Ctrl -->|SPI Bus| SPI_Reg
    Output_Mux --> RF_Out
    RF_Out -->|RF Signal| Analyzer
```

# Using the LMX2594
---
## Hardware Requirement

1. LMX2594 board
2. USB2ANY programmer
3. 5V power
4. Spectrum analyser (optional, for monitoring the output. tinySA Ultra is chosen for this project)
5. SMA RF connector (50Î©)

## Connection 

``` mermaid
graph TD
    A[Computer USB Port] --> B[USB2ANY Adapter]
    B -->|10-pin SPI Connection| C[LMX2594 Module]
    C -->|RF SMA Connection| D[tinySA Ultra Spectrum Analyzer]
```
## Checklist before Usage

- [ ] SPI connection between USB2ANY and LMX2594
- [ ] LMX2594 receives 5V power and proper grounded
- [ ] RF output (RFoutA/RFoutB) is connected with tinySA Ultra
- [ ] Both power LED (red) and lock indicator LED (blue) are on

# Programming the LMX2594 with Python
---

Since the LMX2594 communicates via SPI, we can use a programmer to perform register reads and writes on the board. In this project, the USB2ANY adapter is chosen as the programmer. Usage instructions with Python for the USB2ANY can be found at [[USB2ANY]].

The following snippet illustrates the core steps needed to communicate with the LMX2594 via SPI:

``` python
# 1. Init the USB2ANY
device = USB2ANYDevice("C:\\Program Files\\USB2ANY\\USB2ANY.dll")
device.find_devices()
device.open_device(0)

# 2. Configure SPI
device.configure_spi(clock_freq=1000000)  # 1 MHz

# 3. Write into register
device.write_all_registers(registers_3600mhz)

# 4. Wait for PLL Locking
time.sleep(0.5)

# 5. Check LED and RF Output
```

